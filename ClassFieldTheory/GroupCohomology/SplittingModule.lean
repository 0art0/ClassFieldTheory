import Mathlib
import ClassFieldTheory.GroupCohomology.CyclicGroup

open CategoryTheory Rep BigOperators CategoryTheory.ConcreteCategory

section AugmentationModule'

variable (R : Type) [CommRing R]
variable (G : Type) [Group G] [Fintype G] -- (the Fintype isn't needed)

noncomputable abbrev aug : Rep R G := Limits.kernel (leftRegular.ε R G)

noncomputable abbrev augι : aug R G ⟶ leftRegular R G :=
  Limits.kernel.ι (leftRegular.ε R G)

lemma ε_comp_augι : augι R G ≫ leftRegular.ε R G = 0 :=
  Limits.kernel.condition (leftRegular.ε R G)

lemma ε_apply_augι (v : aug R G) : leftRegular.ε R G (augι R G v) = 0 :=
  sorry
  -- use the previous lemma.

lemma sum_coeff_augι (v : aug R G) : ∑ g : G, (augι R G v) g = 0 :=
  sorry
  -- use the previous lemma.


/-
# TODO

1. prove that we have a short exact sequence in `Rep R G`:

    0 ⟶ aug R G ⟶ leftRegular R G ⟶ trivial R G R ⟶ 0.

2. prove that `leftRegular R G` has trivial cohomology (or find this in Mathlib).
Note that it's already proven to be projective in this category in leftRegular.lean,
so this should follow fairly easily.

3. Define an isomorphism Hⁿ(G,R) ≅ H^{n+1}(G, aug R G).

-/



end AugmentationModule'



section SplittingModule'
variable (R : Type) [CommRing R]
variable (G : Type) [Group G] [Fintype G]
variable (M : Rep R G)

noncomputable abbrev SplittingModule : Type := (aug R G) × M

variable {R G M}
variable (σ : groupCohomology.twoCocycles M)


/-
TODO : find out why this hack is needed, and by the previous instance isn't working.
-/
instance : AddMonoidHomClass (Action.HomSubtype (ModuleCat R) G (Limits.kernel (leftRegular.ε R G))
    (leftRegular R G)) (aug R G).V (leftRegular R G).V := sorry


noncomputable def splittingModuleRepresentation : Representation R G (SplittingModule R G M) where
  toFun g := {
    toFun v := {
      fst := (aug R G).ρ g v.fst
      snd := M.ρ g v.snd + ∑ x : G, augι R G v.fst x • σ ⟨g, x⟩
    }
    map_add' := sorry
    map_smul' := sorry
  }
  map_one' := by
    ext : 1
    · simp
      ext v : 1
      rw [LinearMap.comp_apply]
      dsimp only [Prod.fst_add, Prod.snd_add, Submodule.coe_add, Finsupp.coe_add, Pi.add_apply,
        Prod.mk_add_mk, LinearMap.one_apply, AddHom.toFun_eq_coe, RingHom.id_apply, AddHom.coe_mk,
        Prod.smul_fst, Prod.smul_snd, SetLike.val_smul, Finsupp.coe_smul, Pi.smul_apply,
        smul_eq_mul, Prod.smul_mk, LinearMap.coe_inl, LinearMap.coe_mk, LinearMap.coe_comp,
        Function.comp_apply]
      ext : 1
      · rfl
      · dsimp only
        rw [zero_add]
        have (x : G) : σ (1,x) = σ (1,1)
        · -- essentially the same statement is in Mathlib.
          sorry
        simp only [this]
        rw [←Finset.sum_smul, sum_coeff_augι, zero_smul]
    · ext v : 1
      simp
  map_mul' g₁ g₂ := by
    simp only [map_mul, LinearMap.mul_apply, Limits.equalizer_as_kernel]
    ext v
    · simp only [LinearMap.coe_comp, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.coe_inl,
      Function.comp_apply, map_zero, zero_add, LinearMap.mul_apply, map_sum, map_smul]
    · simp only [LinearMap.coe_comp, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.coe_inl,
      Function.comp_apply, map_zero, zero_add, LinearMap.mul_apply, map_sum, map_smul]
      sorry
    · simp only [LinearMap.coe_comp, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.coe_inr,
      Function.comp_apply, map_zero, Finsupp.coe_zero, Pi.zero_apply, zero_smul,
      Finset.sum_const_zero, add_zero, LinearMap.mul_apply]
    · simp only [LinearMap.coe_comp, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.coe_inr,
      Function.comp_apply, map_zero, Finsupp.coe_zero, Pi.zero_apply, zero_smul,
      Finset.sum_const_zero, add_zero, LinearMap.mul_apply]


noncomputable def splittingModule : Rep R G := Rep.of (splittingModuleRepresentation σ)

noncomputable def splittingModule_ι : M ⟶ splittingModule σ := by
  apply ofHom
  exact {
    val := LinearMap.inr R (aug R G).V M.V
    property g := by
      ext m
      simp only [id_eq, ρ_hom, Function.comp_apply]
      sorry
  }

def splittingModule_π :splittingModule σ ⟶ aug R G := by
  apply ofHom
  exact {
    val := LinearMap.fst R ↑(aug R G).V ↑M.V
    property := sorry
  }


/-

# TODO

1. Show that we have a short exact sequence:

    0 ⟶ M ⟶ splittingModule σ ⟶ aug R G ⟶ 0.

2. Show that the image of `σ` in Z²(G,splittingModule σ) is a coboundary. The formula for the
coboundary is in Milne's lecture notes on class field theory.

3. Assume next that H²(G,M) ≅ R / |G|R and is generated by `σ`, and that H¹(G,M) = 0.

Note that we now have a long exact sequence containing:

    0 ⟶ H¹(G,split) ⟶ R/|G|R ⟶ H²(G,M) ⟶ H²(G,split) ⟶ 0.

using this, prove that H¹(G,split) = 0 and H²(G,split) = 0.
It's sufficient for class field theory to prove this only in the case `R = ℤ` although
the general case is not much harder.

3. *Tate's Theorem* (The statement below is slightly vague)

Assuming that `M` satisfies the conditions above for all subquotients of `G`,
prove that Hⁿ(G,split) = 0 for all `n` (if this is Tate cohomology).
For class field theory, it is sufficient to prove this only for Tate cohomology in dimensions
`0` and `-1`, but if Tate cohomology is not available
then perhaps it makes sense to prove this is all positive dimensions.

This is proved by induction on the subgroup of `G`.
It's proved for cyclic `G` by periodicity together with (3.)
For solvable groups, the inductive step is by inflation-restriction.
For a general group notince that the p-Sylov subgroup of Hⁿ(G,split) is isomorphic to
a subgroup of Hⁿ(Gₚ,split), where Gₚ is a Sylow p-subgroup of G. We then use the fact that
Gₚ is solvable.

Note that for local class field theory, it's enough to prove in the case that `G` is solvable.

4. define an isomorphism between Hⁿ(G,R) and H^{n+1}(G,aug R G), which we have already seen
is isomorphic to H^{n+2}(G,R).
-/




end SplittingModule'








-- section AugmentationModule

-- variable (R : Type) [CommRing R]
-- variable (G : Type) [Group G]

-- /--
-- The augmentation module is the kernel of the map
-- `ε R G : leftRegular R G ⟶ trivial R G R`.
-- -/
-- noncomputable abbrev AugmentationModule := LinearMap.ker (leftRegular.ε R G).hom.hom
--   --Limits.kernel (leftRegular.ε R G)
--   --we have not used Limits.kernel, since this uses the axiom of choice to define the type.
--   --We will (perhaps) need the actual type.

-- lemma AugmentationModule_prop [Fintype G] (v : AugmentationModule R G) :
--     ∑ x : G, v.val x = 0 := sorry



-- noncomputable def augmentationRepresentation : Representation R G <| AugmentationModule R G where
--   toFun g := by
--     apply LinearMap.restrict ((leftRegular R G).ρ g)
--     sorry -- check the file LeftRegular for the relevant lemma.
--   map_one' := sorry
--   map_mul' := sorry

-- lemma augmentationRepresentation_apply (g : G) (v : AugmentationModule R G) :
--     (augmentationRepresentation R G g v).val = (leftRegular R G).ρ g v.val := rfl

-- lemma augmentationRepresentation_apply_apply (g : G) (v : AugmentationModule R G) (x : G) :
--     (augmentationRepresentation R G g v).val x = v.val (g⁻¹ * x) := by
--   rw [augmentationRepresentation_apply]
--   apply leftRegular.coeff_ρReg_apply

-- noncomputable def augmentationRep : Rep R G := of (augmentationRepresentation R G)

-- -- this takes the place of `augmentationRep_apply`
-- def augmentation_ι : augmentationRep R G ⟶ leftRegular R G where
--   hom := ofHom (AugmentationModule R G).subtype

-- @[ext] lemma augmentation_ι_injective : Function.Injective (augmentation_ι R G) :=
--   fun _ _ ↦ Subtype.ext



-- end AugmentationModule


-- section SplittingModule
-- variable (R : Type) [CommRing R]
-- variable (G : Type) [Group G] [Fintype G]
-- variable (M : Rep R G)

-- noncomputable abbrev SplittingModule : Type := (AugmentationModule R G) × M

-- variable {R G M}
-- variable (σ : groupCohomology.twoCocycles M)

-- noncomputable def splittingModuleRepresentation : Representation R G (SplittingModule R G M) where
--   toFun g := {
--     toFun v := {
--       fst := augmentationRepresentation R G g v.fst
--       snd := M.ρ g v.snd + ∑ x : G, v.fst.val x • σ ⟨g, x⟩ -- can replace v.1.val by augmentation_ι v.1
--     }
--     map_add' := sorry
--     map_smul' := sorry
--   }
--   map_one' := by
--     ext : 1
--     · simp
--       ext v : 1
--       rw [LinearMap.comp_apply]
--       dsimp only [Prod.fst_add, Prod.snd_add, Submodule.coe_add, Finsupp.coe_add, Pi.add_apply,
--         Prod.mk_add_mk, LinearMap.one_apply, AddHom.toFun_eq_coe, RingHom.id_apply, AddHom.coe_mk,
--         Prod.smul_fst, Prod.smul_snd, SetLike.val_smul, Finsupp.coe_smul, Pi.smul_apply,
--         smul_eq_mul, Prod.smul_mk, LinearMap.coe_inl, LinearMap.coe_mk, LinearMap.coe_comp,
--         Function.comp_apply]
--       ext : 1
--       · rfl
--       · dsimp only
--         rw [zero_add]
--         have (x : G) : σ (1,x) = σ (1,1)
--         · -- essentially the same statement is in Mathlib.
--           sorry
--         simp only [this]
--         rw [←Finset.sum_smul, AugmentationModule_prop, zero_smul]
--     · ext v : 1
--       simp
--   map_mul' g₁ g₂ := by
--     ext v : 2
--     · simp only [map_mul, LinearMap.mul_apply, LinearMap.coe_comp, LinearMap.coe_mk, AddHom.coe_mk,
--       LinearMap.coe_inl, Function.comp_apply, map_zero, zero_add, map_sum, map_smul, Prod.mk.injEq,
--       true_and]
--       conv => {
--         right
--         right
--         right
--         intro
--         rw [augmentationRepresentation_apply_apply]
--       }
--       sorry
--       /-
--       This follows using the 2-cocycle relation together with the fact that `v` is in the
--       augmentation module, so the sum of its coefficients is zero.
--       -/
--     · simp only [map_mul, LinearMap.mul_apply, LinearMap.coe_comp, LinearMap.coe_mk, AddHom.coe_mk,
--       LinearMap.coe_inr, Function.comp_apply, map_zero, ZeroMemClass.coe_zero, Finsupp.coe_zero,
--       Pi.zero_apply, zero_smul, Finset.sum_const_zero, add_zero]


-- noncomputable def splittingModule : Rep R G := Rep.of (splittingModuleRepresentation σ)






-- noncomputable instance : AddCommMonoid (SplittingModule R G M) where
--   add v w := ⟨v.x + w.x, v.m + w.m, sorry⟩
--   add_assoc := sorry
--   zero := sorry
--   zero_add := sorry
--   add_zero := sorry
--   nsmul := sorry
--   nsmul_zero := sorry
--   nsmul_succ := sorry
--   add_comm := sorry

-- noncomputable instance : Module R (SplittingModule R G M) where
--   smul r v := ⟨r • v.x, r • v.m, sorry⟩
--   one_smul := sorry
--   mul_smul := sorry
--   smul_zero := sorry
--   smul_add := sorry
--   add_smul := sorry
--   zero_smul := sorry

-- variable {R G M} (σ : groupCohomology M 2)

-- def SplittingModule.ρ : Representation R G (SplittingModule R G M) where
--   toFun g := {
--     toFun v := {
--       x := sorry
--       m := sorry
--       x_one := sorry
--     }
--     map_add' := sorry
--     map_smul' := sorry
--   }
--   map_one' := sorry
--   map_mul' := sorry

-- end SplittingModule

/-
The restriction functor from `Rep R G` to `Rep R H`, where `H` is a subgroup
of a group `G`.
-/
-- noncomputable def Rep.restriction : (Rep R G) ⥤ (Rep R H) where
--   obj X := {
--     V := X.V
--     ρ := {
--       toFun := fun ⟨h,_⟩ ↦ CategoryTheory.ConcreteCategory.ofHom (X.ρ h)
--       map_one' := sorry
--       map_mul' := sorry
--     }
--   }
--   map f := {
--     hom := f.hom
--     comm := fun _ ↦ f.comm _
--   }
--   map_id := sorry
--   map_comp := sorry



-- variable (C : Rep R G)

-- #check (restriction H).obj C

-- variable (hC₁ : Unique (groupCohomology ((restriction H).obj C) 1))
-- variable (hC₂ : Nat.card (groupCohomology ((restriction H).obj C) 2) = Nat.card H)
-- variable (H2_gen : groupCohomology ((restriction H).obj C) 2)
-- variable (H2_gen_spec : ∀ σ : groupCohomology ((restriction H).obj C) 2, ∃ n : ℤ, σ = n • H2_gen)


-- instance : AddCommGroup {f : G → R // f 1 = 0} where
--   add f f' := ⟨f + f', sorry⟩
--   add_assoc := sorry
--   zero := ⟨0,rfl⟩
--   zero_add := sorry
--   add_zero := sorry
--   nsmul n f := ⟨n • f,sorry⟩
--   nsmul_zero := sorry
--   nsmul_succ := sorry
--   neg f := ⟨f,sorry⟩
--   sub f g := ⟨f - g, sorry⟩
--   sub_eq_add_neg := sorry
--   zsmul n f := ⟨n • f,sorry⟩
--   zsmul_zero' := sorry
--   zsmul_succ' := sorry
--   zsmul_neg' := sorry
--   neg_add_cancel := sorry
--   add_comm := sorry


-- noncomputable instance : Module R {f : G → R // f 1 = 0} where
--   smul x f := ⟨x • f, sorry⟩
--   one_smul := sorry
--   mul_smul := sorry
--   smul_zero := sorry
--   smul_add := sorry
--   add_smul := sorry
--   zero_smul := sorry

-- #check H2_gen

-- variable {C}
-- /--the 2-cocycle representing the generator of H^2(G,C).-/
-- def φ : G → G → C := sorry


-- noncomputable instance : Representation R G (C × {f : G → R // f 1 = 0}) where
--   toFun g := by
--     by_cases hg : g = 1
--     · exact 1
--     · exact {
--         toFun := by
--           -- need to check all this.
--           intro ⟨c,f⟩
--           constructor
--           · exact C.ρ g c + ∑ h : G, ((f.val h) • φ g h) - (f.val 1) • (φ g 1)
--           · exact {
--             val := by
--               intro h
--               by_cases hgh : g=h
--               · exact f.val 1 - f.val g
--               · exact f.val (g⁻¹ * h)
--             property := sorry
--           }
--         map_add' := sorry
--         map_smul' := sorry
--       }
--   map_one' := sorry
--   map_mul' := sorry



-- noncomputable
-- def splittingModule : Rep R G where
--   V := {
--     carrier := C × {f : G → R // f 1 = 0}
--     isAddCommGroup := inferInstance
--     isModule := inferInstance
--   }
--   ρ := by
--     change G →* _
--     exact {
--       toFun := by
--         change G →* _
--         exact {
--           toFun := by
--             intro g
--             exact {
--               toFun := by
--                 intro ⟨c, f⟩
--                 let φ : G → G → C := sorry -- the 2-cocycle
--                 let c' := C.ρ g c + ∑ h : G, (f.val g : R) • (φ g h : C)
--                 sorry
--               map_add' := sorry
--               map_smul' := sorry
--             }
--           map_one' := sorry
--           map_mul' := sorry
--         }
--       map_one' := sorry
--       map_mul' := sorry
--     }




-- def dimensionShift (r : ℕ) : groupCohomology (Rep.trivial R G R) r ⟶ groupCohomology C (r + 2) := {
--   toFun := sorry
--   map_add' := sorry
--   map_smul' := sorry
-- }

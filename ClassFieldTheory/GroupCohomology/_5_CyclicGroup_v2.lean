import Mathlib
import ClassFieldTheory.GroupCohomology._3_LeftRegular
import ClassFieldTheory.GroupCohomology._4_DimensionShift

/-!
Let `M : Rep R G`, where `G` is a finite cyclic group.
We construct an isomorphism

  `dimensionShift.up.obj M ≅ dimensionShift.down.obj M`.

Using this, construct isomorphisms

  `Hⁿ(G,M) ≅ H^{n+2}(G,M)`.

-/

open
  Rep
  leftRegular
  dimensionShift
  CategoryTheory
  ConcreteCategory
  Limits
  BigOperators
  groupCohomology


variable {R : Type} [CommRing R]
variable (G : Type) [Group G] [IsCyclic G] [Fintype G]
variable {M : Rep R G}

noncomputable section

/--
`gen G` is a generator of the cyclic group `G`.
-/
abbrev gen : G := IsCyclic.exists_generator.choose

variable {G}


/--
Let `G` be a finite cyclic group generated by an element `gen`.

This is the map `coind'₁ M ⟶ coind'₁ M` which takes `f` to `f - f ∘ (ρ gen)`.
This fits into the exact sequence

` 0 ⟶ M ⟶ coind'₁ M ⟶ coind'₁ M ⟶ M ⟶ 0`,

where the other maps are `up_ι` and `down_π` respectively.
-/
def oneSubGen : coind'₁ (R := R) (G := G) ⟶ coind'₁ where
  app M := {
    hom := ofHom {
        toFun f := asₗ f - asₗ f ∘ₗ (leftRegular R G).ρ (gen G)
        map_add' := sorry
        map_smul' := sorry
      }
    comm := sorry
  }

lemma oneSubGen_apply (f : coind'₁.obj M) :
    oneSubGen.app M f = asₗ f - asₗ f ∘ₗ (leftRegular R G).ρ (gen G):= rfl

lemma oneSubGen_apply₂ (f : coind'₁.obj M) (v : leftRegular R G) :
    oneSubGen.app M f v = f (v - (leftRegular R G).ρ (gen G) v) := by
  rw [oneSubGen_apply, LinearMap.sub_apply, LinearMap.comp_apply, ←map_sub, asₗ_apply]

variable (M)
lemma oneSubGen_comp_up_ι : up_ι M ≫ oneSubGen.app M = 0 := sorry

lemma down_π_comp_oneSubGen : oneSubGen.app M ≫ down_π M = 0 := sorry

/-
The sequence `M → coind'₁.obj M ⟶ coind'₁.obj M`, where the first map is
`up_ι` and the second map is `oneSubGen`.
-/
def cx₁ : ShortComplex (Rep R G) where
  f := _
  g := _
  zero := oneSubGen_comp_up_ι M

def cx₂ : ShortComplex (Rep R G) where
  f := _
  g := _
  zero := down_π_comp_oneSubGen M

lemma cx₁_exact : (cx₁ M).Exact := sorry

lemma cx₂_exact : (cx₂ M).Exact := sorry

def upToDown : up.obj M ⟶ down.obj M := by
  let : up.obj M ⟶ coind'₁.obj M
  · apply cokernel.desc (up_ι M) (oneSubGen.app M) (oneSubGen_comp_up_ι M)
  rw [down]
  · apply kernel.lift (down_π M) this
    sorry

lemma oneSubGen_factorization (f : coind'₁.obj M) :
    oneSubGen.app M = cokernel.π _ ≫ upToDown M ≫ kernel.ι _  := by
  sorry

instance : IsIso (upToDown M) :=
  /-
  This follows using the lemmas `cx₁_exact` and `cx₂_exact`.
  -/
  sorry

/--
Redefine `upToDown` as an ismoorphism of functors.
-/
def upToDown' : up (R := R) (G := G) ≅ down where
  hom := {
    app := upToDown
    naturality := sorry
  }
  inv := {
    app M := (asIso (upToDown M)).inv
    naturality := sorry
  }


def periodicCohomology (n : ℕ) : groupCohomology M (n + 1) ≅ groupCohomology M (n + 3) :=
  /-
  We have isomorphisms

    `H^{n+1}(G,M) ≅ H^{n+2}(G,down M)` and  `H^{n+2}(G, up M) ≅ H^{n+3}(G,M)`

  and an isomorphism `up M ≅ down M`.
  -/
  sorry

/--
Let `M` be a representation of a finite cyclic group `G`.
If `H¹(G,M)` and `H²(G,M)` are both zero then `Hⁿ(G,M)` is zero for all `n > 0`.
-/
lemma isZero_ofH1_ofH2 {M : Rep R G} (h1 : IsZero (groupCohomology M 1))
    (h2 : IsZero (groupCohomology M 2)) (n : ℕ) : IsZero (groupCohomology M (n + 1)) := by
  induction n using Nat.twoStepInduction with
  | zero => exact h1
  | one => exact h2
  | more n ih _ =>
    apply IsZero.of_iso ih
    symm
    apply periodicCohomology

import Mathlib
import ClassFieldTheory.GroupCohomology._0_Current_PRs
import ClassFieldTheory.GroupCohomology._1_Basic
import ClassFieldTheory.GroupCohomology._1_restriction

open CategoryTheory
  Limits
  Rep
  groupCohomology
  HomologicalComplex

variable {R G : Type} [CommRing R] [Group G] [DecidableEq G]

variable {H : Type} [Group H] {œÜ : G ‚Üí* H} (surj : Function.Surjective œÜ) [DecidableEq H]

noncomputable def Rep.quotientToInvariantsFunctor :
    Rep R G ‚•§ Rep R H where
  obj M := M.quotientToInvariants œÜ.ker ‚Üì (QuotientGroup.quotientKerEquivOfSurjective œÜ surj).symm
  map f := by
    sorry

instance : (quotientToInvariantsFunctor (R := R) surj).PreservesZeroMorphisms := sorry

set_option quotPrecheck false in
/--
`M ‚Üë H` means the `H` invariants of `M`, as a representation of `G ‚ß∏ H`.
-/
notation M " ‚Üë " surj => (Rep.quotientToInvariantsFunctor surj).obj M

def groupCohomology.cochain_infl :
    quotientToInvariantsFunctor surj ‚ãô cochainsFunctor R H ‚ü∂ cochainsFunctor R G :=
  sorry -- current PR

/--
# TODO :
  move this to the file `Basic.lean`.

The `n`-th group cohomology functor is the composition of the cochains functor and the
`n`-homology functor.
-/
noncomputable def groupCohomology.functor_iso_cochainsFunctor_comp_homology (n : ‚Ñï) :
    functor R G n ‚âÖ cochainsFunctor R G ‚ãô homologyFunctor _ _ n := Iso.refl _

/--
The inflation map `H‚Åø(G‚ß∏H, M ‚Üë H) ‚ü∂ H‚Åø(G,M)` as a natural transformation.
This is defined using the inflation map on cocycles.
-/
noncomputable def groupCohomology.infl (n : ‚Ñï) :
    Rep.quotientToInvariantsFunctor surj ‚ãô functor R H n ‚ü∂ functor R G n :=
  (groupCohomology.cochain_infl surj) ‚ó´ ùüô (homologyFunctor _ _ n)

/--
Suppose we have a short exact sewuence `0 ‚ü∂ A ‚ü∂ B ‚ü∂ C ‚ü∂ 0` in `Rep R G`.
If `H¬π(H,A) = 0` then the invariants form a short exact sequence in `Rep R H`:

  `0 ‚ü∂ A·¥∑ ‚ü∂ B·¥∑ ‚ü∂ C·¥∑ ‚ü∂ 0`, where `K = œÜ.ker`.
-/
lemma quotientToInvariantsFunctor_shortExact_ofShortExact {S : ShortComplex (Rep R G)}
    (hS : S.ShortExact) (hS' : IsZero (H1 (S.X‚ÇÅ ‚Üì œÜ.ker.subtype))) :
    (S.map (quotientToInvariantsFunctor surj)).ShortExact :=
  /-
  This is the opening section of the long exact sequence. The next term is `H¬π(K,S.X‚ÇÅ)`, which
  is assumeed to be zero.
  -/
  sorry

/--
Assume that we have a short exact sequence `0 ‚Üí A ‚Üí B ‚Üí C ‚Üí 0` in `Rep R G`
and that the sequence of `H`- invariants is also a short exact in `Rep R (G ‚ß∏ H)` :

  `0 ‚Üí A·¥¥ ‚Üí B·¥¥ ‚Üí C·¥¥ ‚Üí 0`.

Then we have a commuting square

`   H‚Åø(G ‚ß∏ H, C·¥¥)  ‚ü∂   H^{n+1}(G ‚ß∏ H, A·¥¥) `
`         |                 |             `
`         ‚Üì                 ‚Üì             `
`     H‚Åø(G , C)    ‚ü∂   H^{n+1}(G,A)       `

where the horizontal maps are connecting homomorphisms
and the vertical maps are inflation.
-/
lemma groupCohomology.infl_Œ¥_naturality {S : ShortComplex (Rep R G)} (hS : S.ShortExact)
    (hS' : (S.map (quotientToInvariantsFunctor surj)).ShortExact)  (i j : ‚Ñï) (hij : i + 1 = j) :
    Œ¥ hS' i j hij ‚â´ (infl surj j).app _ = (infl surj i).app _ ‚â´ Œ¥ hS i j hij
    := by
  let C := S.map (cochainsFunctor R G)
  let S' := S.map (quotientToInvariantsFunctor surj)
  let C' := S'.map (cochainsFunctor R H)
  let œÜ : C' ‚ü∂ C := {
    œÑ‚ÇÅ := by
        change (cochainsFunctor _ _).obj S'.X‚ÇÅ ‚ü∂ (cochainsFunctor _ _).obj S.X‚ÇÅ
        exact (cochain_infl surj).app S.X‚ÇÅ
    œÑ‚ÇÇ := by
        change (cochainsFunctor _ _).obj S'.X‚ÇÇ ‚ü∂ (cochainsFunctor _ _).obj S.X‚ÇÇ
        exact (cochain_infl surj).app S.X‚ÇÇ
    œÑ‚ÇÉ := by
        change (cochainsFunctor _ _).obj S'.X‚ÇÉ ‚ü∂ (cochainsFunctor _ _).obj S.X‚ÇÉ
        exact (cochain_infl surj).app S.X‚ÇÉ
    comm‚ÇÅ‚ÇÇ := ((cochain_infl surj).naturality S.f).symm
    comm‚ÇÇ‚ÇÉ := ((cochain_infl surj).naturality S.g).symm
  }
  have ses‚ÇÅ : C.ShortExact := sorry -- current PR
  have ses‚ÇÇ : C'.ShortExact := sorry -- current PR
  exact HomologySequence.Œ¥_naturality œÜ ses‚ÇÇ ses‚ÇÅ i j hij

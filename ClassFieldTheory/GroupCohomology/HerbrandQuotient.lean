import Mathlib
import ClassFieldTheory.GroupCohomology._6_CyclicGroup_v2
import ClassFieldTheory.GroupCohomology.TateCohomology

noncomputable section

variable {R G : Type} [CommRing R] [Group G]
variable [IsCyclic G] [Fintype G]

namespace Representation

variable {A : Type} [AddCommGroup A] [Module R A]
variable (ρ : Representation R G A)

def oneSubGen : A →ₗ[R] A := 1 - ρ (gen G)

def norm : A →ₗ[R] A := ∑ g : G, ρ g

lemma oneSubGen_comp_norm : oneSubGen ρ ∘ₗ norm ρ = 0 := sorry

lemma norm_comp_oneSubGen : norm ρ ∘ₗ oneSubGen ρ = 0 := sorry

end Representation

namespace Rep
open
  CategoryTheory
  Limits
  ConcreteCategory
  groupCohomology
  HomologicalComplex


/--
Let `G` be a finite cyclic group or order `n` generated by `g`, and let `M` be an `RG`-module.
This is the complex `Fin 2` indexed complex of `R` modules whose
objects are both `M` with morphisms given by `1- g` and `1 + g + ... + g ^ (n-1)`.
-/
@[simps] def herbrandComplex (M : Rep R G) : CochainComplex (ModuleCat R) (Fin 2) where
  X _ := M.V
  d
  | 0,0 => 0
  | 0,1 => ofHom M.ρ.oneSubGen
  | 1,0 => ofHom M.ρ.norm
  | 1,1 => 0
  shape i j:= by fin_cases i <;> fin_cases j <;> tauto
  d_comp_d' i _ _ hij hjk := by
    simp only [ComplexShape.up_Rel, Fin.isValue] at hij hjk
    fin_cases i <;> simp [←hij,←hjk] <;> ext : 1
    · exact M.ρ.norm_comp_oneSubGen
    · exact M.ρ.oneSubGen_comp_norm

@[simps] def herbrandComplexFunctor : Rep R G ⥤ CochainComplex (ModuleCat R) (Fin 2) where
  obj M := herbrandComplex M
  map f := {
    f _ := f.hom
    comm' i _ h := by
      sorry
  }
  map_id := sorry
  map_comp := sorry

instance : PreservesFiniteLimits (herbrandComplexFunctor (R := R) (G := G)) :=
  sorry

instance : PreservesFiniteColimits (herbrandComplexFunctor (R := R) (G := G)) :=
  sorry

lemma herbrandComplexFunctor_Exact {S : ShortComplex (Rep R G)}
    (hS : S.ShortExact) : (S.map herbrandComplexFunctor).ShortExact :=
  ShortComplex.ShortExact.map_of_exact hS herbrandComplexFunctor

abbrev herbrandH0 : Rep R G ⥤ ModuleCat R :=
  herbrandComplexFunctor ⋙ homologyFunctor (ModuleCat R) (ComplexShape.up (Fin 2)) 0

abbrev herbrandH1 : Rep R G ⥤ ModuleCat R :=
  herbrandComplexFunctor ⋙ homologyFunctor (ModuleCat R) (ComplexShape.up (Fin 2)) 1

def herbrandH0_iso_TateH0 : herbrandH0 ≅ TateCohomology (R := R) (G := G) 0 :=
  sorry

def herbrandH1_iso_TateH1 : herbrandH1 ≅ TateCohomology (R := R) (G := G) 1 :=
  sorry

def herbrandQuotient (M : Rep R G) : ℚ := Nat.card (herbrandH0.obj M) / Nat.card (herbrandH1.obj M)

lemma herbrandQuotient_nonzero_iff (M : Rep R G) :
  M.herbrandQuotient ≠ 0 ↔ Finite (herbrandH0.obj M) ∧ Finite (herbrandH1.obj M) := sorry

lemma herbrandQuotient_eq_one_of_finite {M : Rep R G} [Finite M] : M.herbrandQuotient = 1 := sorry


section six_term_sequence
variable {S : ShortComplex (Rep R G)} (hS : S.ShortExact)

lemma herbrandComplex_exact : (S.map herbrandComplexFunctor).ShortExact := sorry

abbrev herbrandδ₀ : herbrandH0.obj S.X₃ ⟶ herbrandH1.obj S.X₁ :=
  (herbrandComplexFunctor_Exact hS).δ 0 1 rfl

abbrev herbrandδ₁ : herbrandH1.obj S.X₃ ⟶ herbrandH0.obj S.X₁ :=
  (herbrandComplexFunctor_Exact hS).δ 1 0 rfl

def herbrandSixTermSequence : CochainComplex (ModuleCat R) (Fin 6) where
  X
  | 0 => herbrandH0.obj S.X₁
  | 1 => herbrandH0.obj S.X₂
  | 2 => herbrandH0.obj S.X₃
  | 3 => herbrandH1.obj S.X₁
  | 4 => herbrandH1.obj S.X₂
  | 5 => herbrandH1.obj S.X₃
  d
  | 0,1 => herbrandH0.map S.f
  | 1,2 => herbrandH0.map S.g
  | 2,3 => herbrandδ₀ hS
  | 3,4 => herbrandH1.map S.f
  | 4,5 => herbrandH1.map S.g
  | 5,0 => herbrandδ₁ hS
  | _,_ => 0
  shape i j _ := by fin_cases i <;> fin_cases j <;> tauto
  d_comp_d' i _ _ hij hjk := by
    simp only [ComplexShape.up_Rel, Fin.isValue] at hij hjk
    rw [←hjk,←hij]
    fin_cases i
    · dsimp only [Fin.zero_eta, Fin.isValue, Functor.comp_obj, herbrandComplexFunctor_obj,
        homologyFunctor_obj, Fin.reduceAdd, Functor.comp_map, homologyFunctor_map]
      rw [←homologyMap_comp, ←Functor.map_comp, S.zero, Functor.map_zero, homologyMap_zero]
    · dsimp only [Fin.mk_one, Fin.isValue, Functor.comp_obj, herbrandComplexFunctor_obj,
        homologyFunctor_obj, Fin.reduceAdd, Functor.comp_map, homologyFunctor_map]
      sorry -- find these in Mathlib.
    · sorry
    · dsimp only [Fin.reduceFinMk, Fin.isValue, Functor.comp_obj, herbrandComplexFunctor_obj,
        homologyFunctor_obj, Fin.reduceAdd, Functor.comp_map, homologyFunctor_map]
      rw [←homologyMap_comp, ←Functor.map_comp, S.zero, Functor.map_zero, homologyMap_zero]
    · sorry
    · sorry


lemma herbrandSixTermSequence_exactAt (i : Fin 6) : (herbrandSixTermSequence hS).ExactAt i :=
  /-
  It should be possible to get this out of Mathlib.
  -/
  sorry

lemma herbrandQuotient_nonzero_of_shortExact₃
  (h₁ : S.X₁.herbrandQuotient ≠ 0) (h₂ : S.X₂.herbrandQuotient ≠ 0) :
  S.X₃.herbrandQuotient ≠ 0 := sorry

lemma herbrandQuotient_nonzero_of_shortExact₂
  (h₁ : S.X₁.herbrandQuotient ≠ 0) (h₃ : S.X₃.herbrandQuotient ≠ 0) :
  S.X₂.herbrandQuotient ≠ 0 := sorry

lemma herbrandQuotient_nonzero_of_shortExact₁
  (h₁ : S.X₂.herbrandQuotient ≠ 0) (h₃ : S.X₃.herbrandQuotient ≠ 0) :
  S.X₁.herbrandQuotient ≠ 0 := sorry

lemma herbrandQuotient_eq_of_shortExact
    (h₁ : S.X₁.herbrandQuotient ≠ 0) (h₂ : S.X₂.herbrandQuotient ≠ 0)
    (h₃ : S.X₃.herbrandQuotient ≠ 0) :
    S.X₂.herbrandQuotient = S.X₁.herbrandQuotient * S.X₃.herbrandQuotient :=
  /-
  We have a six term long exact sequence of finite `R`-modules.
  Hence the products of the orders of the even terms is
  equal to the product of the orders of the odd terms.
  This implies the relation.
  -/
  sorry

end six_term_sequence
end Rep

end

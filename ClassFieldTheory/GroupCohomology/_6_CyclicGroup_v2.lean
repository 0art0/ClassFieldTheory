import Mathlib
import ClassFieldTheory.GroupCohomology._3_LeftRegular
import ClassFieldTheory.GroupCohomology._5_DimensionShift

/-!
Let `M : Rep R G`, where `G` is a finite cyclic group.
We construct an exact sequence

  `0 ‚ü∂ M ‚ü∂ coind‚ÇÅ'.obj M ‚ü∂ ind‚ÇÅ'.obj M ‚ü∂ M ‚ü∂ 0`.

Using this sequence, we construct an isomorphism

  `dimensionShift.up.obj M ‚âÖ dimensionShift.down.obj M`.

Using this, construct isomorphisms

  `H‚Åø‚Å∫¬π(G,M) ‚âÖ H‚Åø‚Å∫¬≥(G,M)`.

-/

open
  Finsupp
  Rep
  leftRegular
  dimensionShift
  CategoryTheory
  ConcreteCategory
  Limits
  BigOperators
  groupCohomology


variable {R : Type} [CommRing R]
variable (G : Type) [Group G] [IsCyclic G] [Finite G] [DecidableEq G]
variable (M : Rep R G)

noncomputable section

/--
`gen G` is a generator of the cyclic group `G`.
-/
abbrev gen : G := IsCyclic.exists_generator.choose

variable {G}

@[simp] lemma ofHom_sub (A B : ModuleCat R) (f‚ÇÅ f‚ÇÇ : A ‚Üí‚Çó[R] B) :
  (ofHom (f‚ÇÅ - f‚ÇÇ) : A ‚ü∂ B) = ofHom f‚ÇÅ - ofHom f‚ÇÇ := rfl

@[simp] lemma ofHom_add (A B : ModuleCat R) (f‚ÇÅ f‚ÇÇ : A ‚Üí‚Çó[R] B) :
  (ofHom (f‚ÇÅ + f‚ÇÇ) : A ‚ü∂ B) = ofHom f‚ÇÅ + ofHom f‚ÇÇ := rfl

@[simp] lemma ofHom_zero (A B : ModuleCat R) :
  (ofHom 0 : A ‚ü∂ B) = 0 := rfl

@[simp] lemma ofHom_one (A : ModuleCat R) :
  (ofHom 1 : A ‚ü∂ A) = ùüô A := rfl

@[simp] lemma Rep.œÅ_mul_eq_comp (M : Rep R G) (x y : G) :
    Action.œÅ M (x * y) = (Action.œÅ M y) ‚â´ (Action.œÅ M x) := by
  rw [Rep.Action_œÅ_eq_œÅ, map_mul]
  rfl

section Representation

variable {A : Type} [AddCommGroup A] [Module R A] (œÅ : Representation R G A)

@[simps] def Representation.map‚ÇÅ : (G ‚Üí A) ‚Üí‚Çó[R] (G ‚Üí A) where
  toFun f x := f x - f ((gen G)‚Åª¬π * x)
  map_add' := sorry
  map_smul' := sorry

lemma Representation.map‚ÇÅ_comm (g : G) :
    map‚ÇÅ ‚àò‚Çó œÅ.coind‚ÇÅ' g = œÅ.coind‚ÇÅ' g ‚àò‚Çó map‚ÇÅ  := by
  apply LinearMap.ext
  intro
  apply funext
  intro
  simp [mul_assoc]

omit [Finite G] [DecidableEq G] in
lemma Representation.map‚ÇÅ_comp_coind_Œπ :
    map‚ÇÅ (R := R) (G := G) (A := A) ‚àò‚Çó coind‚ÇÅ'_Œπ = 0 := by
  ext; simp

omit [Finite G] [DecidableEq G] in
lemma Representation.map‚ÇÅ_ker :
    LinearMap.ker (map‚ÇÅ (R := R) (G := G) (A := A)) = LinearMap.range coind‚ÇÅ'_Œπ :=
  sorry

@[simps!] def Representation.map‚ÇÇ : (G ‚Üí‚ÇÄ A) ‚Üí‚Çó[R] (G ‚Üí‚ÇÄ A) :=
  LinearMap.id - lmapDomain _ _ (fun x ‚Ü¶ x * gen G)

omit [Finite G] [DecidableEq G] in
@[simp] lemma Representation.map‚ÇÇ_comp_lsingle (x : G) :
    map‚ÇÇ (R := R) (G := G) (A := A) ‚àò‚Çó lsingle x = lsingle x - lsingle (x * gen G) := by
  ext
  simp [map‚ÇÇ, LinearMap.sub_comp]

omit [Finite G] [DecidableEq G] in
lemma Representation.map‚ÇÇ_comm (g : G) :
    map‚ÇÇ ‚àò‚Çó œÅ.ind‚ÇÅ' g = œÅ.ind‚ÇÅ' g ‚àò‚Çó map‚ÇÇ := by
  ext x : 1
  rw [LinearMap.comp_assoc, ind‚ÇÅ'_comp_lsingle, LinearMap.comp_assoc, map‚ÇÇ_comp_lsingle,
    LinearMap.comp_sub, ind‚ÇÅ'_comp_lsingle, ‚ÜêLinearMap.comp_assoc, map‚ÇÇ_comp_lsingle, mul_assoc,
    LinearMap.sub_comp, ind‚ÇÅ'_comp_lsingle]

omit [Finite G] [DecidableEq G] in
lemma Representation.ind‚ÇÅ'_œÄ_comp_map‚ÇÇ :
    ind‚ÇÅ'_œÄ ‚àò‚Çó map‚ÇÇ (R := R) (G := G) (A := A) = 0 := by
  ext : 1
  rw [LinearMap.comp_assoc, map‚ÇÇ_comp_lsingle, LinearMap.comp_sub,
    LinearMap.zero_comp, sub_eq_zero, ind‚ÇÅ'_œÄ_comp_lsingle, ind‚ÇÅ'_œÄ_comp_lsingle]

lemma Representation.map‚ÇÇ_range :
    LinearMap.range (map‚ÇÇ (R := R) (G := G) (A := A)) = LinearMap.ker ind‚ÇÅ'_œÄ :=
  sorry


end Representation

namespace Rep

/--
The map `coind‚ÇÅ'.obj M ‚ü∂ coind‚ÇÅ' M` which takes a function `f : G ‚Üí M.V` to
`x ‚Ü¶ f x - f (gen G * x)`.
-/
def map‚ÇÅ : coind‚ÇÅ' (R := R) (G := G) ‚ü∂ coind‚ÇÅ' where
  app M := {
    hom := ofHom Representation.map‚ÇÅ
    comm g := by
      ext : 1
      apply Representation.map‚ÇÅ_comm
  }
  naturality := sorry

lemma coind_Œπ_gg_map‚ÇÅ_app : coind‚ÇÅ'_Œπ.app M ‚â´ map‚ÇÅ.app M = 0 := by
  ext : 2
  apply Representation.map‚ÇÅ_comp_coind_Œπ

lemma coind_Œπ_gg_map‚ÇÅ : coind‚ÇÅ'_Œπ ‚â´ map‚ÇÅ (R := R) (G := G) = 0 := by
  ext : 2
  apply coind_Œπ_gg_map‚ÇÅ_app


def map‚ÇÇ : ind‚ÇÅ' (R := R) (G := G) ‚ü∂ ind‚ÇÅ' where
  app M := {
    hom := ofHom Representation.map‚ÇÇ
    comm g := by
      ext : 1
      apply Representation.map‚ÇÇ_comm
  }
  naturality := sorry

omit [Finite G] [DecidableEq G] in
lemma map‚ÇÇ_app_gg_ind‚ÇÅ'_œÄ_app :  map‚ÇÇ.app M ‚â´ ind‚ÇÅ'_œÄ.app M = 0 := by
  ext : 2
  apply Representation.ind‚ÇÅ'_œÄ_comp_map‚ÇÇ

omit [Finite G] [DecidableEq G] in
lemma map‚ÇÇ_gg_ind‚ÇÅ'_œÄ : map‚ÇÇ (R := R) (G := G) ‚â´ ind‚ÇÅ'_œÄ = 0 := by
  ext : 2
  apply map‚ÇÇ_app_gg_ind‚ÇÅ'_œÄ_app

/--
Let `M` be a representation of a finite cyclic group `G`.
Then the following square commutes

  ` coind‚ÇÅ'.obj M -------> coind‚ÇÅ'.obj M `
  `      |                      |        `
  `      |                      |        `
  `      ‚Üì                      ‚Üì        `
  `   ind‚ÇÅ'.obj M ------->   ind‚ÇÅ'.obj M `

The vertical maps are the canonical isomorphism `ind‚ÇÅ'_iso_coind‚ÇÅ`
and the horizontal maps are `map‚ÇÅ` and `map‚ÇÇ`.
-/
lemma map‚ÇÅ_comp_ind‚ÇÅ'_iso_coind‚ÇÅ' :
    map‚ÇÅ.app M ‚â´ (ind‚ÇÅ'_iso_coind‚ÇÅ'.app M).inv = (ind‚ÇÅ'_iso_coind‚ÇÅ'.app M).inv ‚â´ map‚ÇÇ.app M :=
  sorry


/--
For a cyclic group `G`, this is the sequence of representations of a cyclic group:

` 0 ‚ü∂ M ‚ü∂ coind‚ÇÅ'.obj M ‚ü∂ ind‚ÇÅ'.obj M ‚ü∂ M ‚ü∂ 0 `.

The middle map is `map‚ÇÅ ‚â´ ind‚ÇÅ'_iso_coind‚ÇÅ'.inv`, which is
equal to `ind‚ÇÅ'_iso_coind‚ÇÅ'.inv ‚â´ map‚ÇÇ`. The sequence is exact.

It might be sensible to make this into a functor.
-/
def periodicitySequence : CochainComplex (Rep R G) (Fin 4) where
  X
  | 0 => M
  | 1 => coind‚ÇÅ'.obj M
  | 2 => ind‚ÇÅ'.obj M
  | 3 => M
  d
  | 0,1 => coind‚ÇÅ'_Œπ.app M
  | 1,2 => map‚ÇÅ.app M ‚â´ (ind‚ÇÅ'_iso_coind‚ÇÅ'.app M).inv
  | 2,3 => ind‚ÇÅ'_œÄ.app M
  | _,_ => 0
  d_comp_d' :=
    /-
    Proved in lemmas above in the non-trivial cases.
    -/
    sorry

lemma periodicitySequence_exactAt_one : (periodicitySequence M).ExactAt 1 := sorry

lemma periodicitySequence_exactAt_two : (periodicitySequence M).ExactAt 2 := sorry

def up_obj_iso_down_obj : up.obj M ‚âÖ down.obj M :=
  /-
  `up.obj M` is the cokernel of the first map is `periodicitySequence`,
  so is isomorphic to the image of the second map. This in turn is isomorphic to the
  kernel of the last map, which is `down.obj M`.
  -/
  sorry

def up_iso_down : up (R := R) (G := G) ‚âÖ down where
  hom := {
    app M := (up_obj_iso_down_obj M).hom
    naturality := sorry
  }
  inv := {
    app M := (up_obj_iso_down_obj M).inv
    naturality := sorry
  }

def periodicCohomology (n : ‚Ñï) :
    functor R G (n + 1) ‚âÖ functor R G (n + 3) := by
  apply Iso.trans (down_Œ¥iso_natTrans n)
  apply Iso.trans (isoWhiskerRight up_iso_down.symm _)
  apply up_Œ¥iso_natTrans

/--
Let `M` be a representation of a finite cyclic group `G`.
If `H¬π(G,M)` and `H¬≤(G,M)` are both zero then `H‚Åø(G,M)` is zero for all `n > 0`.
-/
lemma isZero_ofH1_ofH2 {M : Rep R G} (h1 : IsZero (groupCohomology M 1))
    (h2 : IsZero (groupCohomology M 2)) (n : ‚Ñï) : IsZero (groupCohomology M (n + 1)) := by
  induction n using Nat.twoStepInduction with
  | zero => exact h1
  | one => exact h2
  | more n ih _ =>
    apply IsZero.of_iso ih
    apply (periodicCohomology n).symm.app



section six_term_sequence
variable {S : ShortComplex (Rep R G)} (hS : S.ShortExact)

def herbrandSixTermSequence : CochainComplex (ModuleCat R) (Fin 6) where
  X
  | 0 => groupCohomology S.X‚ÇÅ 2
  | 1 => groupCohomology S.X‚ÇÇ 2
  | 2 => groupCohomology S.X‚ÇÉ 2
  | 3 => groupCohomology S.X‚ÇÅ 1
  | 4 => groupCohomology S.X‚ÇÇ 1
  | 5 => groupCohomology S.X‚ÇÉ 1
  d
  | 0,1 => (functor R G 2).map S.f
  | 1,2 => (functor R G 2).map S.g
  | 2,3 => Œ¥ hS 2 3 rfl ‚â´ (periodicCohomology 0).inv.app S.X‚ÇÅ
  | 3,4 => (functor R G 1).map S.f
  | 4,5 => (functor R G 1).map S.g
  | 5,0 => Œ¥ hS 1 2 rfl
  | _,_ => 0
  shape i j _ := by fin_cases i,j <;> tauto
  d_comp_d' i _ _ hij hjk := by
    simp only [ComplexShape.up_Rel, Fin.isValue] at hij hjk
    rw [‚Üêhjk,‚Üêhij]
    sorry


lemma herbrandSixTermSequence_exactAt (i : Fin 6) : (herbrandSixTermSequence hS).ExactAt i :=
  /-
  It should be possible to get this out of Mathlib.
  -/
  sorry

def herbrandQuotient : ‚Ñö := Nat.card (groupCohomology M 2) / Nat.card (groupCohomology M 1)

lemma herbrandQuotient_nonzero_of_shortExact‚ÇÉ
  (h‚ÇÅ : S.X‚ÇÅ.herbrandQuotient ‚â† 0) (h‚ÇÇ : S.X‚ÇÇ.herbrandQuotient ‚â† 0) :
  S.X‚ÇÉ.herbrandQuotient ‚â† 0 := sorry

lemma herbrandQuotient_nonzero_of_shortExact‚ÇÇ
  (h‚ÇÅ : S.X‚ÇÅ.herbrandQuotient ‚â† 0) (h‚ÇÉ : S.X‚ÇÉ.herbrandQuotient ‚â† 0) :
  S.X‚ÇÇ.herbrandQuotient ‚â† 0 := sorry

lemma herbrandQuotient_nonzero_of_shortExact‚ÇÅ
  (h‚ÇÅ : S.X‚ÇÇ.herbrandQuotient ‚â† 0) (h‚ÇÉ : S.X‚ÇÉ.herbrandQuotient ‚â† 0) :
  S.X‚ÇÅ.herbrandQuotient ‚â† 0 := sorry

lemma herbrandQuotient_eq_of_shortExact
    (h‚ÇÅ : S.X‚ÇÅ.herbrandQuotient ‚â† 0) (h‚ÇÇ : S.X‚ÇÇ.herbrandQuotient ‚â† 0)
    (h‚ÇÉ : S.X‚ÇÉ.herbrandQuotient ‚â† 0) :
    S.X‚ÇÇ.herbrandQuotient = S.X‚ÇÅ.herbrandQuotient * S.X‚ÇÉ.herbrandQuotient :=
  /-
  We have a six term long exact sequence of finite `R`-modules.
  Hence the products of the orders of the even terms is
  equal to the product of the orders of the odd terms.
  This implies the relation.
  -/
  sorry

end six_term_sequence

end Rep

namespace Representation

variable [Fintype G]
variable {A : Type} [AddCommGroup A] [Module R A]
variable (œÅ : Representation R G A)

def oneSubGen : A ‚Üí‚Çó[R] A := 1 - œÅ (gen G)

def norm  : A ‚Üí‚Çó[R] A := ‚àë g : G, œÅ g

lemma oneSubGen_comp_norm : oneSubGen œÅ ‚àò‚Çó norm œÅ = 0 := sorry

lemma norm_comp_oneSubGen : norm œÅ ‚àò‚Çó oneSubGen œÅ = 0 := sorry

end Representation

namespace Rep
variable [Fintype G] (M : Rep R G)
open HomologicalComplex
/--
Let `G` be a finite cyclic group or order `n` generated by `g`, and let `M` be an `RG`-module.
This is the complex `Fin 2` indexed complex of `R` modules whose
objects are both `M` with morphisms given by `1- g` and `1 + g + ... + g ^ (n-1)`.
-/
@[simps] def herbrandComplex : CochainComplex (ModuleCat R) (Fin 2) where
  X _ := M.V
  d
  | 0,0 => 0
  | 0,1 => ofHom M.œÅ.oneSubGen
  | 1,0 => ofHom M.œÅ.norm
  | 1,1 => 0
  shape i j:= by fin_cases i <;> fin_cases j <;> tauto
  d_comp_d' i _ _ hij hjk := by
    simp only [ComplexShape.up_Rel, Fin.isValue] at hij hjk
    fin_cases i <;> simp [‚Üêhij,‚Üêhjk] <;> ext : 1
    ¬∑ exact M.œÅ.norm_comp_oneSubGen
    ¬∑ exact M.œÅ.oneSubGen_comp_norm

def herbrandH0_iso_groupCohomology_two : homology (herbrandComplex M) 0 ‚âÖ groupCohomology M 2 :=
  sorry

def herbrandH1_iso_groupCohomology_one : homology (herbrandComplex M) 1 ‚âÖ groupCohomology M 1 :=
  sorry



end Rep
